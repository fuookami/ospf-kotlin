package fuookami.ospf.kotlin.framework.solver

import java.util.concurrent.*
import kotlin.time.*
import kotlinx.coroutines.*
import kotlinx.coroutines.future.*
import fuookami.ospf.kotlin.utils.math.*
import fuookami.ospf.kotlin.utils.functional.*
import fuookami.ospf.kotlin.core.frontend.model.*
import fuookami.ospf.kotlin.core.frontend.model.mechanism.*
import fuookami.ospf.kotlin.core.frontend.variable.*
import fuookami.ospf.kotlin.core.frontend.inequality.*
import fuookami.ospf.kotlin.core.backend.solver.output.*

interface BendersDecompositionSolver {
    val name: String

    suspend fun solveMaster(
        name: String,
        metaModel: LinearMetaModel,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): Ret<SolverOutput>

    @OptIn(DelicateCoroutinesApi::class)
    fun solveMasterAsync(
        name: String,
        metaModel: LinearMetaModel,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): CompletableFuture<Ret<SolverOutput>> {
        return GlobalScope.future {
            return@future this@BendersDecompositionSolver.solveMaster(name, metaModel, toLogModel, registrationStatusCallBack, solvingStatusCallBack)
        }
    }

    suspend fun solveMaster(
        name: String,
        metaModel: QuadraticMetaModel,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): Ret<SolverOutput>

    @OptIn(DelicateCoroutinesApi::class)
    fun solveMasterAsync(
        name: String,
        metaModel: QuadraticMetaModel,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): CompletableFuture<Ret<SolverOutput>> {
        return GlobalScope.future {
            return@future this@BendersDecompositionSolver.solveMaster(name, metaModel, toLogModel, registrationStatusCallBack, solvingStatusCallBack)
        }
    }

    /**
     * Sub Problem Solving Result (with cuts if fixed variables are provided)
     *
     * @property cuts       list of cuts generated by sub problem, if fixed variables are provided.
     * Otherwise, there should not be any fixed variables in the sub problem model. In other words, the fixed variables should be replaced with their values.
     *
     */
    sealed interface LinearSubResult {
        val cuts: List<LinearInequality>?
    }

    data class LinearFeasibleResult(
        val result: SolverOutput,
        val dualSolution: Solution,
        override val cuts: List<LinearInequality>?
    ) : LinearSubResult {
        val obj: Flt64 by result::obj
        val solution: Solution by result::solution
        val time: Duration by result::time
        val possibleBestObj by result::possibleBestObj
        val gap: Flt64 by result::gap
    }

    data class LinearInfeasibleResult(
        val farkasDualSolution: Solution,
        override val cuts: List<LinearInequality>?
    ) : LinearSubResult

    suspend fun solveSub(
        name: String,
        metaModel: LinearMetaModel,
        objectVariable: AbstractVariableItem<*, *>,
        fixedVariables: Map<AbstractVariableItem<*, *>, Flt64>,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): Ret<LinearSubResult>

    @OptIn(DelicateCoroutinesApi::class)
    fun solveSubAsync(
        name: String,
        metaModel: LinearMetaModel,
        objectVariable: AbstractVariableItem<*, *>,
        fixedVariables: Map<AbstractVariableItem<*, *>, Flt64>,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): CompletableFuture<Ret<LinearSubResult>> {
        return GlobalScope.future {
            return@future this@BendersDecompositionSolver.solveSub(name, metaModel, objectVariable, fixedVariables, toLogModel, registrationStatusCallBack, solvingStatusCallBack)
        }
    }

    sealed interface QuadraticSubResult {
        val linearCuts: List<LinearInequality>?
        val quadraticCuts: List<QuadraticInequality>?
    }

    data class QuadraticFeasibleResult(
        val result: SolverOutput,
        val qpiSolution: Solution,
        val dualSolution: Solution,
        override val linearCuts: List<LinearInequality>?,
        override val quadraticCuts: List<QuadraticInequality>?,
    ) : QuadraticSubResult {
        val obj: Flt64 by result::obj
        val solution: Solution by result::solution
        val time: Duration by result::time
        val possibleBestObj by result::possibleBestObj
        val gap: Flt64 by result::gap
    }

    data class QuadraticInfeasibleResult(
        val qpiSolution: Solution,
        val farkasDualSolution: Solution,
        override val linearCuts: List<LinearInequality>?,
        override val quadraticCuts: List<QuadraticInequality>?,
    ) : QuadraticSubResult

    suspend fun solveSub(
        name: String,
        metaModel: QuadraticMetaModel,
        objectVariable: AbstractVariableItem<*, *>,
        fixedVariables: Map<AbstractVariableItem<*, *>, Flt64>,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): Ret<QuadraticSubResult>

    @OptIn(DelicateCoroutinesApi::class)
    fun solveSubAsync(
        name: String,
        metaModel: QuadraticMetaModel,
        objectVariable: AbstractVariableItem<*, *>,
        fixedVariables: Map<AbstractVariableItem<*, *>, Flt64>,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): CompletableFuture<Ret<QuadraticSubResult>> {
        return GlobalScope.future {
            return@future this@BendersDecompositionSolver.solveSub(name, metaModel, objectVariable, fixedVariables, toLogModel, registrationStatusCallBack, solvingStatusCallBack)
        }
    }
}
