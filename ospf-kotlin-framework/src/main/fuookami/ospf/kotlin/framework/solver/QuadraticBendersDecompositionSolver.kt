package fuookami.ospf.kotlin.framework.solver

import java.util.concurrent.*
import kotlin.time.*
import kotlinx.coroutines.*
import kotlinx.coroutines.future.*
import fuookami.ospf.kotlin.utils.math.*
import fuookami.ospf.kotlin.utils.functional.*
import fuookami.ospf.kotlin.core.frontend.model.*
import fuookami.ospf.kotlin.core.frontend.model.mechanism.*
import fuookami.ospf.kotlin.core.frontend.variable.*
import fuookami.ospf.kotlin.core.frontend.inequality.*
import fuookami.ospf.kotlin.core.backend.solver.output.*

interface LinearBendersDecompositionSolver {
    val name: String

    suspend fun solveMaster(
        name: String,
        metaModel: LinearMetaModel,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): Ret<SolverOutput>

    @OptIn(DelicateCoroutinesApi::class)
    fun solveMasterAsync(
        name: String,
        metaModel: LinearMetaModel,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): CompletableFuture<Ret<SolverOutput>> {
        return GlobalScope.future {
            return@future this@LinearBendersDecompositionSolver.solveMaster(name, metaModel, toLogModel, registrationStatusCallBack, solvingStatusCallBack)
        }
    }

    /**
     * Sub Problem Solving Result (with cuts if fixed variables are provided)
     *
     * @property cuts           list of cuts generated by sub problem, if fixed variables are provided.
     * Otherwise, there should not be any fixed variables in the sub problem model. In other words, the fixed variables should be replaced with their values.
     */
    sealed interface LinearSubResult {
        val cuts: List<LinearInequality>?
    }

    data class LinearFeasibleResult(
        val result: FeasibleSolverOutput,
        val dualSolution: LinearDualSolution,
        override val cuts: List<LinearInequality>?
    ) : LinearSubResult {
        val obj: Flt64 by result::obj
        val solution: Solution by result::solution
        val time: Duration by result::time
        val possibleBestObj by result::possibleBestObj
        val gap: Flt64 by result::gap
    }

    data class LinearInfeasibleResult(
        val farkasDualSolution: LinearDualSolution,
        override val cuts: List<LinearInequality>?
    ) : LinearSubResult

    suspend fun solveSub(
        name: String,
        metaModel: LinearMetaModel,
        objectVariable: AbstractVariableItem<*, *>,
        fixedVariables: Map<AbstractVariableItem<*, *>, Flt64>,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): Ret<LinearSubResult>

    @OptIn(DelicateCoroutinesApi::class)
    fun solveSubAsync(
        name: String,
        metaModel: LinearMetaModel,
        objectVariable: AbstractVariableItem<*, *>,
        fixedVariables: Map<AbstractVariableItem<*, *>, Flt64>,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): CompletableFuture<Ret<LinearSubResult>> {
        return GlobalScope.future {
            return@future this@LinearBendersDecompositionSolver.solveSub(name, metaModel, objectVariable, fixedVariables, toLogModel, registrationStatusCallBack, solvingStatusCallBack)
        }
    }
}

interface QuadraticBendersDecompositionSolver : LinearBendersDecompositionSolver {
    suspend fun solveMaster(
        name: String,
        metaModel: QuadraticMetaModel,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): Ret<SolverOutput>

    @OptIn(DelicateCoroutinesApi::class)
    fun solveMasterAsync(
        name: String,
        metaModel: QuadraticMetaModel,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): CompletableFuture<Ret<SolverOutput>> {
        return GlobalScope.future {
            return@future this@QuadraticBendersDecompositionSolver.solveMaster(name, metaModel, toLogModel, registrationStatusCallBack, solvingStatusCallBack)
        }
    }

    /**
     * Sub Problem Solving Result (with cuts if fixed variables are provided)
     *
     * @property linearCuts     list of linear cuts generated by sub problem, if fixed variables are provided.
     * @property quadraticCuts  list of quadratic cuts generated by sub problem, if fixed variables are provided.
     * Otherwise, there should not be any fixed variables in the sub problem model. In other words, the fixed variables should be replaced with their values.
     */
    sealed interface QuadraticSubResult {
        val linearCuts: List<LinearInequality>?
        val quadraticCuts: List<QuadraticInequality>?
    }

    data class QuadraticFeasibleResult(
        val result: FeasibleSolverOutput,
        val dualSolution: QuadraticDualSolution,
        override val linearCuts: List<LinearInequality>?,
        override val quadraticCuts: List<QuadraticInequality>?,
    ) : QuadraticSubResult {
        val obj: Flt64 by result::obj
        val solution: Solution by result::solution
        val time: Duration by result::time
        val possibleBestObj by result::possibleBestObj
        val gap: Flt64 by result::gap
    }

    data class QuadraticInfeasibleResult(
        val farkasDualSolution: QuadraticDualSolution,
        override val linearCuts: List<LinearInequality>?,
        override val quadraticCuts: List<QuadraticInequality>?,
    ) : QuadraticSubResult

    suspend fun solveSub(
        name: String,
        metaModel: QuadraticMetaModel,
        objectVariable: AbstractVariableItem<*, *>,
        fixedVariables: Map<AbstractVariableItem<*, *>, Flt64>,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): Ret<QuadraticSubResult>

    @OptIn(DelicateCoroutinesApi::class)
    fun solveSubAsync(
        name: String,
        metaModel: QuadraticMetaModel,
        objectVariable: AbstractVariableItem<*, *>,
        fixedVariables: Map<AbstractVariableItem<*, *>, Flt64>,
        toLogModel: Boolean = false,
        registrationStatusCallBack: RegistrationStatusCallBack? = null,
        solvingStatusCallBack: SolvingStatusCallBack? = null
    ): CompletableFuture<Ret<QuadraticSubResult>> {
        return GlobalScope.future {
            return@future this@QuadraticBendersDecompositionSolver.solveSub(name, metaModel, objectVariable, fixedVariables, toLogModel, registrationStatusCallBack, solvingStatusCallBack)
        }
    }
}
